import cv2
import numpy
import math
from networktables import NetworkTable
from enum import Enum

class GripPipeline:
    """
    An OpenCV pipeline generated by GRIP.
    """

    # Arrays to send
    centerX = []
    centerY = []
    width = []
    height = []
    ratio = []

    # IP addresses
    ip = 'roborio-2643-frc.local'
    ip2 = 'localhost'
    ip3 = '10.26.43.20'
    ip4 = '192.168.137.1'

    # Runs network tables
    NetworkTable.setIPAddress(ip)
    NetworkTable.setClientMode()
    NetworkTable.initialize()
    table = NetworkTable.getTable("Vision")

    def cameraStatus(self):
        """
        Retrieves the status of camera from network tables sent by the robot Java code.
        """
        return self.table.getNumber("Camera Call", -1)

    def autoMode(self):
        """
        Determines auto mode or telop mode from robot java code.
        """
        return self.table.getNumber("Auto Mode", -1)

    def __init__(self):
        self.__blur_type = BlurType.Box_Blur
        self.__blur_radius = 6.306306306306306

        self.blur_output = None

        self.__hsv_threshold_input = self.blur_output
        self.__hsv_threshold_hue = [113.0, 180.0]
        self.__hsv_threshold_saturation = [101.0, 246.0]
        self.__hsv_threshold_value = [183.0, 255.0]

        self.hsv_threshold_output = None

        self.__find_contours_input = self.hsv_threshold_output
        self.__find_contours_external_only = False

        self.find_contours_output = None

        self.__filter_contours_contours = self.find_contours_output
        self.__filter_contours_min_area = 0.0
        self.__filter_contours_min_perimeter = 0.0
        self.__filter_contours_min_width = 0.0
        self.__filter_contours_max_width = 1000.0
        self.__filter_contours_min_height = 0.0
        self.__filter_contours_max_height = 1000.0
        self.__filter_contours_solidity = [80, 100]
        self.__filter_contours_max_vertices = 100.0
        self.__filter_contours_min_vertices = 4.0
        self.__filter_contours_min_ratio = 0.0
        self.__filter_contours_max_ratio = 1000.0

        self.filter_contours_output = None

    """GRIP GENERATED"""
    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step Blur0:
        self.__blur_input = source0
        (self.blur_output) = self.__blur(self.__blur_input, self.__blur_type, self.__blur_radius)

        # Step HSV_Threshold0:
        self.__hsv_threshold_input = self.blur_output
        (self.hsv_threshold_output) = self.__hsv_threshold(self.__hsv_threshold_input, self.__hsv_threshold_hue, self.__hsv_threshold_saturation, self.__hsv_threshold_value)

        # Step Find_Contours0:
        self.__find_contours_input = self.hsv_threshold_output
        (self.find_contours_output) = self.__find_contours(self.__find_contours_input, self.__find_contours_external_only)

        # Step Filter_Contours0:
        self.__filter_contours_contours = self.find_contours_output
        (self.filter_contours_output), self.centerX, self.centerY, self.height, self.width, self.ratio = self.__filter_contours(self.__filter_contours_contours, self.__filter_contours_min_area, self.__filter_contours_min_perimeter, self.__filter_contours_min_width, self.__filter_contours_max_width, self.__filter_contours_min_height, self.__filter_contours_max_height, self.__filter_contours_solidity, self.__filter_contours_max_vertices, self.__filter_contours_min_vertices, self.__filter_contours_min_ratio, self.__filter_contours_max_ratio)
        self.sendDataToServer(self)
        #print(self.centerX)

    def cameraOffline(self):
        """
        Returns whether the camera is online or offline and sends to network table
        """
        self.table.putString("Camera Status", "Camera is Offline")

    def cameraOnline(self):
        self.table.putString("Camera Status", "Camera is Online")

    @staticmethod
    def sendDataToServer(self):
        """
        Sends data to network table. At the moment, it is only sending
        necessary code to be used during robot movement and auto.
        """

        # Arrays
        tmpX = []
        tmpHeight = []

        # Values* NOT USED ATM
        tmpH1 = 0
        tmpH2 = 0
        tmpX1 = 0
        tmpX2 = 0
        xCheck = 0

        # Checks whether the values of width and height make the correct ratio of retroreflective tape
        for x in range(len(self.ratio)):
            if 0.75 < self.ratio[x] < 5.0:
                if x < len(self.centerX):
                    tmpX.insert(1, self.centerX[x])
                    tmpHeight.insert(1, self.height[x])
                    '''
        for x in range(len(tmpHeight)):
            if tmpHeight[x] > tmpH1:
                tmpH1 = tmpHeight[x]
                tmpX1 = tmpX[x]
                xCheck = x
        #print(tmp1)

        for x in range(len(tmpHeight)):
            if tmpHeight[x] >= tmpH2 and x != xCheck:
                tmpH2 = tmpHeight[x]
                tmpX2 = tmpX[x]

        del tmpX[:]
        del tmpHeight[:]

        tmpX.insert(0, tmpX1)
        tmpHeight.insert(0, tmpH1)
        tmpX.insert(1, tmpX2)
        tmpHeight.insert(1, tmpH2)
        '''

        # Puts data into networktable
        self.table.putNumberArray("CenterX", tmpX)
        self.table.putNumberArray("Height", tmpHeight)

    """GRIP GENERATED"""
    @staticmethod
    def __blur(src, type, radius):
        """Softens an image using one of several filters.
        Args:
            src: The source mat (numpy.ndarray).
            type: The blurType to perform represented as an int.
            radius: The radius for the blur as a float.
        Returns:
            A numpy.ndarray that has been blurred.
        """

        if type is BlurType.Box_Blur:
            ksize = int(2 * round(radius) + 1)
            return cv2.blur(src, (ksize, ksize))
        elif type is BlurType.Gaussian_Blur:
            ksize = int(6 * round(radius) + 1)
            return cv2.GaussianBlur(src, (ksize, ksize), round(radius))
        elif type is BlurType.Median_Filter:
            ksize = int(2 * round(radius) + 1)
            return cv2.medianBlur(src, ksize)
        else:
            return cv2.bilateralFilter(src, -1, round(radius), round(radius))

    """GRIP GENERATED"""
    @staticmethod
    def __hsv_threshold(input, hue, sat, val):
        """Segment an image based on hue, saturation, and value ranges.
        Args:
            input: A BGR numpy.ndarray.
            hue: A list of two numbers the are the min and max hue.
            sat: A list of two numbers the are the min and max saturation.
            lum: A list of two numbers the are the min and max value.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HSV)
        return cv2.inRange(out, (hue[0], sat[0], val[0]),  (hue[1], sat[1], val[1]))

    """GRIP GENERATED"""
    @staticmethod
    def __find_contours(input, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input: A numpy.ndarray.
            external_only: A boolean. If true only external contours are found.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """
        if external_only:
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
            method = cv2.CHAIN_APPROX_SIMPLE
            im2, contours, hierarchy =cv2.findContours(input, mode=mode, method=method)
        return contours

    """GRIP GENERATED"""
    @staticmethod
    def __filter_contours(input_contours, min_area, min_perimeter, min_width, max_width,
                          min_height, max_height, solidity, max_vertex_count, min_vertex_count,
                          min_ratio, max_ratio):
        """Filters out contours that do not meet certain criteria.
        Args:
            input_contours: Contours as a list of numpy.ndarray.
            min_area: The minimum area of a contour that will be kept.
            min_perimeter: The minimum perimeter of a contour that will be kept.
            min_width: Minimum width of a contour.
            max_width: MaxWidth maximum width.
            min_height: Minimum height.
            max_height: Maximimum height.
            solidity: The minimum and maximum solidity of a contour.
            min_vertex_count: Minimum vertex Count of the contours.
            max_vertex_count: Maximum vertex Count.
            min_ratio: Minimum ratio of width to height.
            max_ratio: Maximum ratio of width to height.
        Returns:
            Contours as a list of numpy.ndarray.
        """

        # Arrays to return
        contours = []

        centerXs = []
        centerYs = []

        widths = []
        heights = []

        ratios = []

        for contour in input_contours:
            x, y, w, h = cv2.boundingRect(contour)
            if min_width < w < max_width and min_height < h < max_height:
                area = cv2.contourArea(contour)

                centerXs.insert(1, x + (w / 2))
                centerYs.insert(1, y + (h / 2))

                widths.insert(1, w)
                heights.insert(1, h)

                ratios.insert(1, h / w)

                hull = cv2.convexHull(contour)
                hullCA = cv2.contourArea(hull)
                solid = 100 * area / hullCA

                size_correct = area > min_area and\
                               cv2.arcLength(contour, True) > min_perimeter and\
                               hullCA != 0
                substance_correct = solidity[1] < solid < solidity[0] and\
                                    len(contour) > min_vertex_count and\
                                    len(contour) > max_vertex_count
                if size_correct and substance_correct:
                    ratio = float(w) / h
                    #ratio insert* NOT USED
                    #ratios.insert(1, h / w)
                    if min_ratio < ratio < max_ratio:
                        output.append(contour)
        return contours, centerXs, centerYs, heights, widths, ratios


BlurType = Enum('BlurType', 'Box_Blur Gaussian_Blur Median_Filter Bilateral_Filter')
